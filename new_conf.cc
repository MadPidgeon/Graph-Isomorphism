#include "ext.h"
#include "conf2.h"

int moddist( int a, int b, int n ) {
	int c = (a-b+n)%n;
	return std::min( c, n-c );
}

RelationalStructure EulerianStructure( int n, std::vector<int> ext_cycle ) {
	std::vector<int> R( n*n*n, 5 );
	std::deque<int> C( n );
	std::iota( C.begin(), C.end(), 1 );
	for( auto t : all_tuples( n, 3 ) ) {
		if( t[0] == t[1] ) {
			if( t[1] == t[2] ) {
				R[ polynomial_evaluation( t, n ) ] = 0;
			} else {
				R[ polynomial_evaluation( t, n ) ] = 1;
			}
		} else if( t[1] == t[2] ) {
			R[ polynomial_evaluation( t, n ) ] = 2;
		} else if( t[0] == t[2] ) {
			R[ polynomial_evaluation( t, n ) ] = 3;
		}
	}
	for( int i : range(0,ext_cycle.size()-2) ) {
		R[ polynomial_evaluation( std::vector<int>({ext_cycle[i],ext_cycle[i+1],ext_cycle[i+2]}), n ) ] = 4;
		R[ polynomial_evaluation( std::vector<int>({ext_cycle[i],ext_cycle[i+2],ext_cycle[i+1]}), n ) ] = 4;
		R[ polynomial_evaluation( std::vector<int>({ext_cycle[i+2],ext_cycle[i+1],ext_cycle[i]}), n ) ] = 4;
		R[ polynomial_evaluation( std::vector<int>({ext_cycle[i+2],ext_cycle[i],ext_cycle[i+1]}), n ) ] = 4;
		R[ polynomial_evaluation( std::vector<int>({ext_cycle[i+1],ext_cycle[i+2],ext_cycle[i]}), n ) ] = 4;
		R[ polynomial_evaluation( std::vector<int>({ext_cycle[i+1],ext_cycle[i],ext_cycle[i+2]}), n ) ] = 4;
	}
	return RelationalStructure( std::move( C ), std::move( R ), 3 );
}

int main() {
	int n1 = 5;
	std::vector<int> R1( n1*n1*n1 );
	std::deque<int> C1( n1 );
	std::iota( C1.begin(), C1.end(), 1 );
	for( auto t : all_tuples( n1, 3 ) ) {
		if( t[0] == t[1] ) {
			if( t[1] == t[2] ) {
				R1[ polynomial_evaluation( t, n1 ) ] = 0;
			} else {
				R1[ polynomial_evaluation( t, n1 ) ] = 1;
			}
		} else if( t[1] == t[2] ) {
			R1[ polynomial_evaluation( t, n1 ) ] = 2;
		} else if( t[0] == t[2] ) {
			R1[ polynomial_evaluation( t, n1 ) ] = 3;
		} else {
			int a = t[0], b = t[1], c = t[2];
			if( moddist(a,c,n1) == 1 )
				std::swap( b, c );
			if( moddist(b,c,n1) == 1 )
				std::swap( a, c );
			if( moddist(a,b,n1) == 1 and moddist(b,c,n1) == (n1-1)/2 and  moddist(a,c,n1) == (n1-1)/2 ) {
				R1[ polynomial_evaluation( t, n1 ) ] = 4;
			} else 
				R1[ polynomial_evaluation( t, n1 ) ] = 5;
		}
	}
	RelationalStructure conf1( std::move( C1 ), std::move( R1 ), 3 );
	// conf15.individualise(std::deque<int>({0}));
	conf1.refine();
	std::cout << conf1 << std::endl;
	std::cout << "---------------------------------" << std::endl;
	int n2 = 6;
	std::vector<int> R2( n2*n2*n2 );
	std::deque<int> C2( n2 );
	std::iota( C2.begin(), C2.end(), 1 );
	for( auto t : all_tuples( n2, 3 ) ) {
		if( t[0] == t[1] ) {
			if( t[1] == t[2] ) {
				R2[ polynomial_evaluation( t, n2 ) ] = 0;
			} else {
				R2[ polynomial_evaluation( t, n2 ) ] = 1;
			}
		} else if( t[1] == t[2] ) {
			R2[ polynomial_evaluation( t, n2 ) ] = 2;
		} else if( t[0] == t[2] ) {
			R2[ polynomial_evaluation( t, n2 ) ] = 3;
		} else if( (t[0]+1)*(t[1]+1)%(n2+1) == (t[2]+1) )
			R2[ polynomial_evaluation( t, n2 ) ] = 4;
		else
			R2[ polynomial_evaluation( t, n2 ) ] = 5;
	}
	RelationalStructure conf2( std::move( C2 ), std::move( R2 ), 3 );
	conf2.refine();
	std::cout << conf2 << std::endl;
	std::cout << "---------------------------------" << std::endl;
	RelationalStructure conf3 = EulerianStructure( 5, std::vector<int>({0,1,4,2,3,1,2,0,4,3,0,1}) );
	std::cout << conf3 << std::endl;
	conf3.refine();
	std::cout << conf3 << std::endl;
	std::cout << "---------------------------------" << std::endl;
	RelationalStructure conf4 = EulerianStructure( 5, std::vector<int>({0,1,2,3,4,0,2,4,1,3,0,1}) );
	std::cout << conf4 << std::endl;
	conf4.refine();
	std::cout << conf4 << std::endl;
	std::cout << "---------------------------------" << std::endl;
	std::vector<std::vector<int>> Eulers = {{1,2,5,4,3,5,1,4,2,3,1,2},{1,2,5,4,3,5,1,3,2,4,1,2},{1,2,5,4,3,2,4,1,5,3,1,2},{1,2,5,4,3,2,4,1,3,5,1,2},{1,2,5,4,3,1,5,3,2,4,1,2},{1,2,5,4,3,1,4,2,3,5,1,2},{1,2,5,4,2,3,5,1,4,3,1,2},{1,2,5,4,2,3,5,1,3,4,1,2},{1,2,5,4,2,3,4,1,5,3,1,2},{1,2,5,4,2,3,4,1,3,5,1,2},{1,2,5,4,2,3,1,5,3,4,1,2},{1,2,5,4,2,3,1,4,3,5,1,2},{1,2,5,4,1,5,3,4,2,3,1,2},{1,2,5,4,1,5,3,2,4,3,1,2},{1,2,5,4,1,3,4,2,3,5,1,2},{1,2,5,4,1,3,2,4,3,5,1,2},{1,2,5,3,4,5,1,4,2,3,1,2},{1,2,5,3,4,5,1,3,2,4,1,2},{1,2,5,3,4,2,3,1,5,4,1,2},{1,2,5,3,4,2,3,1,4,5,1,2},{1,2,5,3,4,1,5,4,2,3,1,2},{1,2,5,3,4,1,3,2,4,5,1,2},{1,2,5,3,2,4,5,1,4,3,1,2},{1,2,5,3,2,4,5,1,3,4,1,2},{1,2,5,3,2,4,3,1,5,4,1,2},{1,2,5,3,2,4,3,1,4,5,1,2},{1,2,5,3,2,4,1,5,4,3,1,2},{1,2,5,3,2,4,1,3,4,5,1,2},{1,2,5,3,1,5,4,3,2,4,1,2},{1,2,5,3,1,5,4,2,3,4,1,2},{1,2,5,3,1,4,3,2,4,5,1,2},{1,2,5,3,1,4,2,3,4,5,1,2},{1,2,5,1,4,5,3,4,2,3,1,2},{1,2,5,1,4,5,3,2,4,3,1,2},{1,2,5,1,4,3,5,4,2,3,1,2},{1,2,5,1,4,3,2,4,5,3,1,2},{1,2,5,1,4,2,3,5,4,3,1,2},{1,2,5,1,4,2,3,4,5,3,1,2},{1,2,5,1,3,5,4,3,2,4,1,2},{1,2,5,1,3,5,4,2,3,4,1,2},{1,2,5,1,3,4,5,3,2,4,1,2},{1,2,5,1,3,4,2,3,5,4,1,2},{1,2,5,1,3,2,4,5,3,4,1,2},{1,2,5,1,3,2,4,3,5,4,1,2},{1,2,4,5,3,4,1,5,2,3,1,2},{1,2,4,5,3,4,1,3,2,5,1,2},{1,2,4,5,3,2,5,1,4,3,1,2},{1,2,4,5,3,2,5,1,3,4,1,2},{1,2,4,5,3,1,5,2,3,4,1,2},{1,2,4,5,3,1,4,3,2,5,1,2},{1,2,4,5,2,3,5,1,4,3,1,2},{1,2,4,5,2,3,5,1,3,4,1,2},{1,2,4,5,2,3,4,1,5,3,1,2},{1,2,4,5,2,3,4,1,3,5,1,2},{1,2,4,5,2,3,1,5,3,4,1,2},{1,2,4,5,2,3,1,4,3,5,1,2},{1,2,4,5,1,4,3,5,2,3,1,2},{1,2,4,5,1,4,3,2,5,3,1,2},{1,2,4,5,1,3,5,2,3,4,1,2},{1,2,4,5,1,3,2,5,3,4,1,2},{1,2,4,3,5,4,1,5,2,3,1,2},{1,2,4,3,5,4,1,3,2,5,1,2},{1,2,4,3,5,2,3,1,5,4,1,2},{1,2,4,3,5,2,3,1,4,5,1,2},{1,2,4,3,5,1,4,5,2,3,1,2},{1,2,4,3,5,1,3,2,5,4,1,2},{1,2,4,3,2,5,4,1,5,3,1,2},{1,2,4,3,2,5,4,1,3,5,1,2},{1,2,4,3,2,5,3,1,5,4,1,2},{1,2,4,3,2,5,3,1,4,5,1,2},{1,2,4,3,2,5,1,4,5,3,1,2},{1,2,4,3,2,5,1,3,5,4,1,2},{1,2,4,3,1,5,3,2,5,4,1,2},{1,2,4,3,1,5,2,3,5,4,1,2},{1,2,4,3,1,4,5,3,2,5,1,2},{1,2,4,3,1,4,5,2,3,5,1,2},{1,2,4,1,5,4,3,5,2,3,1,2},{1,2,4,1,5,4,3,2,5,3,1,2},{1,2,4,1,5,3,4,5,2,3,1,2},{1,2,4,1,5,3,2,5,4,3,1,2},{1,2,4,1,5,2,3,5,4,3,1,2},{1,2,4,1,5,2,3,4,5,3,1,2},{1,2,4,1,3,5,4,3,2,5,1,2},{1,2,4,1,3,5,2,3,4,5,1,2},{1,2,4,1,3,4,5,3,2,5,1,2},{1,2,4,1,3,4,5,2,3,5,1,2},{1,2,4,1,3,2,5,4,3,5,1,2},{1,2,4,1,3,2,5,3,4,5,1,2},{1,2,3,5,4,3,1,5,2,4,1,2},{1,2,3,5,4,3,1,4,2,5,1,2},{1,2,3,5,4,2,5,1,4,3,1,2},{1,2,3,5,4,2,5,1,3,4,1,2},{1,2,3,5,4,1,5,2,4,3,1,2},{1,2,3,5,4,1,3,4,2,5,1,2},{1,2,3,5,2,4,5,1,4,3,1,2},{1,2,3,5,2,4,5,1,3,4,1,2},{1,2,3,5,2,4,3,1,5,4,1,2},{1,2,3,5,2,4,3,1,4,5,1,2},{1,2,3,5,2,4,1,5,4,3,1,2},{1,2,3,5,2,4,1,3,4,5,1,2},{1,2,3,5,1,4,5,2,4,3,1,2},{1,2,3,5,1,4,2,5,4,3,1,2},{1,2,3,5,1,3,4,5,2,4,1,2},{1,2,3,5,1,3,4,2,5,4,1,2},{1,2,3,4,5,3,1,5,2,4,1,2},{1,2,3,4,5,3,1,4,2,5,1,2},{1,2,3,4,5,2,4,1,5,3,1,2},{1,2,3,4,5,2,4,1,3,5,1,2},{1,2,3,4,5,1,4,2,5,3,1,2},{1,2,3,4,5,1,3,5,2,4,1,2},{1,2,3,4,2,5,4,1,5,3,1,2},{1,2,3,4,2,5,4,1,3,5,1,2},{1,2,3,4,2,5,3,1,5,4,1,2},{1,2,3,4,2,5,3,1,4,5,1,2},{1,2,3,4,2,5,1,4,5,3,1,2},{1,2,3,4,2,5,1,3,5,4,1,2},{1,2,3,4,1,5,4,2,5,3,1,2},{1,2,3,4,1,5,2,4,5,3,1,2},{1,2,3,4,1,3,5,4,2,5,1,2},{1,2,3,4,1,3,5,2,4,5,1,2},{1,2,3,1,5,4,3,5,2,4,1,2},{1,2,3,1,5,4,2,5,3,4,1,2},{1,2,3,1,5,3,4,5,2,4,1,2},{1,2,3,1,5,3,4,2,5,4,1,2},{1,2,3,1,5,2,4,5,3,4,1,2},{1,2,3,1,5,2,4,3,5,4,1,2},{1,2,3,1,4,5,3,4,2,5,1,2},{1,2,3,1,4,5,2,4,3,5,1,2},{1,2,3,1,4,3,5,4,2,5,1,2},{1,2,3,1,4,3,5,2,4,5,1,2},{1,2,3,1,4,2,5,4,3,5,1,2},{1,2,3,1,4,2,5,3,4,5,1,2}};
	for( auto& cycle : Eulers ) {
		for( int& x : cycle )
			x--;
		RelationalStructure conf5 = EulerianStructure( 5, cycle );
		conf5.refine();
		if( conf5.isHomogeneous() /*conf5.skeleton(2).isClique()*/ )
			std::cout << cycle << std::endl;
	}
	std::cout << "---------------------------------" << std::endl;
	matrix<int> M5({ 	{0,1,1,1,2,2},
						{1,0,1,2,1,2},
						{1,1,0,2,2,1},
						{1,2,2,0,1,1},
						{2,1,2,1,0,1},
						{2,2,1,1,1,0}	});
	std::deque<int> C5( 6 );
	std::iota( C5.begin(), C5.end(), 0 );
	std::vector<int> R5(6*6);
	for( auto t : all_tuples( 6, 2 ) )
		R5[polynomial_evaluation( t, 6 )] = M5.at( t[0], t[1] );
	RelationalStructure conf5( std::move( C5 ), std::move( R5 ), 2 );
	conf5.refine();
	std::cout << conf5 << std::endl;
	std::cout << "---------------------------------" << std::endl;
	matrix<int> M6({{ 0 , 1 , 2 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 1 , 2 },
		{ 1 , 0 , 1 , 2 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 2 },
		{ 2 , 1 , 0 , 1 , 2 , 2 , 2 , 2 , 1 , 2 , 2 , 2 },
		{ 2 , 2 , 1 , 0 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 },
		{ 2 , 2 , 2 , 1 , 0 , 1 , 2 , 2 , 2 , 1 , 2 , 2 },
		{ 2 , 2 , 2 , 2 , 1 , 0 , 1 , 2 , 2 , 1 , 2 , 2 },
		{ 1 , 2 , 2 , 2 , 2 , 1 , 0 , 2 , 2 , 2 , 1 , 2 },
		{ 2 , 1 , 2 , 2 , 2 , 2 , 2 , 0 , 2 , 2 , 1 , 1 },
		{ 2 , 2 , 1 , 1 , 2 , 2 , 2 , 2 , 0 , 2 , 2 , 1 },
		{ 2 , 2 , 2 , 2 , 1 , 1 , 2 , 2 , 2 , 0 , 2 , 1 },
		{ 1 , 2 , 2 , 2 , 2 , 2 , 1 , 1 , 2 , 2 , 0 , 2 },
		{ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 1 , 1 , 1 , 2 , 0 }});
	std::deque<int> C6( 10 );
	std::iota( C6.begin(), C6.end(), 0 );
	std::vector<int> R6(10*10);
	for( auto t : all_tuples( 10, 2 ) )
		R6[polynomial_evaluation( t, 10 )] = M6.at( t[0], t[1] );
	RelationalStructure conf6( std::move( C6 ), std::move( R6 ), 2 );
	conf6.refine();
	std::cout << conf6 << std::endl;
	std::cout << "---------------------------------" << std::endl;



	matrix<int> M15({	{0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
						{2,0,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1},
						{2,2,0,1,2,2,2,1,2,2,1,1,1,1,2,1,2,1,2,1,2,2,1,1,1,1,1,1},
						{2,2,1,0,2,2,1,2,1,1,2,2,1,2,1,2,1,1,1,2,1,1,2,2,1,1,1,1},
						{2,2,2,2,0,2,1,1,1,1,2,2,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1},
						{2,2,2,2,2,0,1,1,1,2,1,2,1,1,1,2,2,1,1,1,1,2,1,2,1,1,1,2},
						{2,2,2,1,1,1,0,2,2,2,1,1,2,2,2,1,1,2,2,1,1,1,1,1,1,2,1,1},
						{2,2,1,2,1,1,2,0,2,1,2,1,2,2,1,2,1,2,1,2,1,1,1,1,2,1,1,1},
						{2,1,2,1,1,1,2,2,0,2,2,1,2,1,1,1,1,1,2,2,2,2,1,1,2,1,1,1},
						{2,1,2,1,1,2,2,1,2,0,1,2,2,1,1,1,1,1,2,1,1,2,1,2,1,2,1,2},
						{2,1,1,2,2,1,1,2,2,1,0,2,2,1,1,1,1,1,1,2,2,1,2,1,2,1,2,1},
						{2,1,1,2,2,2,1,1,1,2,2,0,2,1,1,1,1,1,1,1,1,1,2,2,1,2,2,2},
						{2,1,1,1,1,1,2,2,2,2,2,2,0,1,1,1,1,2,1,1,1,1,1,1,2,2,2,2},
						{1,2,1,2,1,1,2,2,1,1,1,1,1,0,2,2,1,2,2,2,1,1,2,2,1,2,1,1},
						{1,2,2,1,2,1,2,1,1,1,1,1,1,2,0,1,2,2,2,1,2,1,2,1,1,2,2,1},
						{1,2,1,2,1,2,1,2,1,1,1,1,1,2,1,0,2,2,1,2,1,2,1,2,2,1,1,2},
						{1,2,2,1,2,2,1,1,1,1,1,1,1,1,2,2,0,2,1,1,2,2,1,1,2,1,2,2},
						{1,2,1,1,1,1,2,2,1,1,1,1,2,2,2,2,2,0,1,1,1,1,1,1,2,2,2,2},
						{1,1,2,1,1,1,2,1,2,2,1,1,1,2,2,1,1,1,0,2,2,2,2,2,1,2,1,1},
						{1,1,1,2,1,1,1,2,2,1,2,1,1,2,1,2,1,1,2,0,2,2,2,2,2,1,1,1},
						{1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,2,2,0,2,2,1,2,1,2,1},
						{1,1,2,1,1,2,1,1,2,2,1,1,1,1,1,2,2,1,2,2,2,0,1,2,2,1,1,2},
						{1,1,1,2,2,1,1,1,1,1,2,2,1,2,2,1,1,1,2,2,2,1,0,2,1,2,2,1},
						{1,1,1,2,1,2,1,1,1,2,1,2,1,2,1,2,1,1,2,2,1,2,2,0,1,2,1,2},
						{1,1,1,1,1,1,1,2,2,1,2,1,2,1,1,2,2,2,1,2,2,2,1,1,0,1,2,2},
						{1,1,1,1,1,1,2,1,1,2,1,2,2,2,2,1,1,2,2,1,1,1,2,2,1,0,2,2},
						{1,1,1,1,2,1,1,1,1,1,2,2,2,1,2,1,2,2,1,1,2,1,2,1,2,2,0,2},
						{1,1,1,1,1,2,1,1,1,2,1,2,2,1,1,2,2,2,1,1,1,2,1,2,2,2,2,0}});
	std::deque<int> C( 28 );
	std::iota( C.begin(), C.end(), 0 );
	std::vector<int> r(28*28);
	for( auto t : all_tuples( 28, 2 ) )
		r[polynomial_evaluation( t, 28 )] = M15.at( t[0], t[1] );
	RelationalStructure conf15( std::move( C ), std::move( r ), 2 );
	conf15.individualise(std::deque<int>({0}));
	conf15.refine();
	std::cout << conf15 << std::endl;
}